# Vulnerability Fix

## Overview
Identify, assess, and fix security vulnerabilities in a systematic and secure manner.

## Vulnerability Assessment Process

### 1. Identify Vulnerability
- [ ] Understand the vulnerability type
- [ ] Determine affected components
- [ ] Check vulnerability databases (CVE, NVD)
- [ ] Verify vulnerability exists in your code
- [ ] Assess exploitability

### 2. Risk Assessment
- [ ] **Severity**: Critical, High, Medium, Low
- [ ] **Impact**: Data breach, system compromise, DoS
- [ ] **Exploitability**: Easy, Moderate, Difficult
- [ ] **Affected Users**: All users, privileged users, specific roles
- [ ] **Business Impact**: Financial, reputational, legal

### 3. Prioritize Fix
Use CVSS (Common Vulnerability Scoring System):
- **Critical (9.0-10.0)**: Fix immediately
- **High (7.0-8.9)**: Fix within 7 days
- **Medium (4.0-6.9)**: Fix within 30 days
- **Low (0.1-3.9)**: Fix in next release

## Common Vulnerabilities & Fixes

### SQL Injection

**Vulnerable Code:**
```javascript
// BAD: SQL Injection vulnerability
const query = `SELECT * FROM users WHERE id = ${userId}`;
```

**Fixed Code:**
```javascript
// GOOD: Parameterized query
const query = 'SELECT * FROM users WHERE id = ?';
const results = await db.query(query, [userId]);

// OR using ORM
const user = await User.findById(userId);
```

### Cross-Site Scripting (XSS)

**Vulnerable Code:**
```javascript
// BAD: XSS vulnerability
document.getElementById('output').innerHTML = userInput;
```

**Fixed Code:**
```javascript
// GOOD: Escaped output
document.getElementById('output').textContent = userInput;

// OR use sanitization library
import DOMPurify from 'dompurify';
const clean = DOMPurify.sanitize(userInput);
```

### Cross-Site Request Forgery (CSRF)

**Fix:**
```javascript
// Add CSRF token middleware
const csrf = require('csurf');
app.use(csrf({ cookie: true }));

// Include token in forms
<input type="hidden" name="_csrf" value="{{ csrfToken }}" />
```

### Insecure Direct Object References

**Vulnerable Code:**
```javascript
// BAD: No authorization check
app.get('/api/documents/:id', async (req, res) => {
  const doc = await Document.findById(req.params.id);
  res.json(doc);
});
```

**Fixed Code:**
```javascript
// GOOD: Authorization check
app.get('/api/documents/:id', async (req, res) => {
  const doc = await Document.findById(req.params.id);
  
  // Verify user has access
  if (doc.ownerId !== req.user.id && !req.user.isAdmin) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  res.json(doc);
});
```

### Weak Password Storage

**Vulnerable Code:**
```javascript
// BAD: Plain text or weak hashing
user.password = md5(password); // Insecure!
```

**Fixed Code:**
```javascript
// GOOD: Strong hashing with bcrypt
const bcrypt = require('bcrypt');
const saltRounds = 12;
user.password = await bcrypt.hash(password, saltRounds);

// Verify password
const isValid = await bcrypt.compare(inputPassword, user.password);
```

### Hardcoded Secrets

**Vulnerable Code:**
```javascript
// BAD: Hardcoded credentials
const API_KEY = 'sk_live_abc123xyz789';
const DB_PASSWORD = 'SuperSecret123';
```

**Fixed Code:**
```javascript
// GOOD: Environment variables
const API_KEY = process.env.API_KEY;
const DB_PASSWORD = process.env.DB_PASSWORD;

// Use secret management service
const secrets = await getSecrets(); // AWS Secrets Manager, HashiCorp Vault
```

### Path Traversal

**Vulnerable Code:**
```javascript
// BAD: Path traversal vulnerability
app.get('/files/:filename', (req, res) => {
  const file = path.join(__dirname, 'uploads', req.params.filename);
  res.sendFile(file);
});
```

**Fixed Code:**
```javascript
// GOOD: Validate and sanitize path
const path = require('path');

app.get('/files/:filename', (req, res) => {
  const filename = path.basename(req.params.filename);
  const file = path.join(__dirname, 'uploads', filename);
  
  // Verify file is within allowed directory
  if (!file.startsWith(path.join(__dirname, 'uploads'))) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  res.sendFile(file);
});
```

### XML External Entity (XXE)

**Fix:**
```javascript
// Disable external entities in XML parser
const libxmljs = require('libxmljs');

const xmlDoc = libxmljs.parseXml(xmlString, {
  noent: false,  // Disable entity expansion
  nonet: true    // Disable network access
});
```

### Insecure Deserialization

**Vulnerable Code:**
```javascript
// BAD: Unsafe deserialization
const userData = JSON.parse(untrustedInput);
```

**Fixed Code:**
```javascript
// GOOD: Validate schema
const Ajv = require('ajv');
const ajv = new Ajv();

const schema = {
  type: 'object',
  properties: {
    name: { type: 'string' },
    age: { type: 'number' }
  },
  required: ['name'],
  additionalProperties: false
};

const validate = ajv.compile(schema);
const userData = JSON.parse(untrustedInput);

if (!validate(userData)) {
  throw new Error('Invalid data structure');
}
```

## Fix Implementation Steps

1. **Create Hotfix Branch**
```bash
git checkout -b security/fix-vulnerability-CVE-XXXX
```

2. **Implement Fix**
   - [ ] Write failing test demonstrating vulnerability
   - [ ] Implement secure solution
   - [ ] Verify fix with security test
   - [ ] Add regression tests

3. **Security Testing**
   - [ ] Manual testing
   - [ ] Automated security scans
   - [ ] Penetration testing (for critical fixes)
   - [ ] Code review by security team

4. **Documentation**
   - [ ] Document the vulnerability
   - [ ] Explain the fix
   - [ ] Update security documentation
   - [ ] Create incident report

5. **Deployment**
   - [ ] Test in staging environment
   - [ ] Create deployment plan
   - [ ] Deploy to production
   - [ ] Monitor for issues

6. **Post-Deployment**
   - [ ] Verify fix in production
   - [ ] Update vulnerability databases
   - [ ] Notify affected parties (if required)
   - [ ] Publish security advisory (if needed)

## Prevention Measures
- [ ] Add security tests to CI/CD
- [ ] Implement automated scanning
- [ ] Regular dependency updates
- [ ] Security code reviews
- [ ] Developer security training
- [ ] Use security linters
- [ ] Follow secure coding standards

## Communication
- [ ] Notify security team
- [ ] Inform stakeholders
- [ ] Update users (if needed)
- [ ] Publish CVE (if warranted)
- [ ] Document lessons learned

